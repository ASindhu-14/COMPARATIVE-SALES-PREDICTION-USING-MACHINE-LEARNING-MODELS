# -*- coding: utf-8 -*-
"""Comparative Sales prediction using machine learning models.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pLJ3o8ajpBPiyM_bNs4WBrtbLfAQhDKp

#Import libraries
"""

!pip install feature_engine

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
# %matplotlib inline
import warnings
warnings.filterwarnings('ignore')
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import mean_squared_error, mean_absolute_error, mean_absolute_percentage_error, r2_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.neighbors import KNeighborsRegressor, RadiusNeighborsRegressor
from sklearn.tree import DecisionTreeRegressor
from xgboost import XGBRegressor, XGBRFRegressor
from lightgbm import LGBMRegressor
from sklearn.neural_network import MLPRegressor
from sklearn.preprocessing import StandardScaler, FunctionTransformer, PowerTransformer, OneHotEncoder, MinMaxScaler
from sklearn.compose import ColumnTransformer
from sklearn.feature_selection import SelectKBest, f_regression, SelectPercentile, SelectFromModel, RFE, SequentialFeatureSelector
from sklearn.pipeline import Pipeline
from feature_engine.selection import DropConstantFeatures, DropDuplicateFeatures, DropCorrelatedFeatures
from sklearn.impute import SimpleImputer
from yellowbrick.regressor import PredictionError, ResidualsPlot

"""#Load data"""

df = pd.read_excel('Superstore.xlsx')
df.head()

df.shape

df.info()

"""#Exploratory Data Analysis

##Data Quality
"""

duplicated = df.duplicated().sum()
print(duplicated)

missing_values = df.isnull().sum()
total_missing_values = (missing_values).sum()
total_cells = np.prod(df.shape)
percent_missing = (total_missing_values/total_cells) * 100
print("Percent of data that is missing :", percent_missing)
print(missing_values)

df.dropna(inplace=True)

for column in df.columns:
    num_distinct_values = len(df[column].unique())
    print(f"{column}: {num_distinct_values} distinct values")

df.shape

"""##Category Analysis"""

plt.figure(figsize=(10,5))
# Prepare data
category_counts = df['Category'].value_counts()
labels = category_counts.index
values = category_counts.values

# Create interactive pie chart
fig = px.pie(
    names=labels,
    values=values,
    title="Category Distribution",
    hole=0,  # Use >0 for donut chart
)

fig.update_traces(
    textinfo='percent+label',
    pull=[0.1, 0.005, 0.005],  # Explode first slice
    marker=dict(colors=['deeppink', 'teal', 'skyblue']),
    textfont_size=14
)

fig.update_layout(showlegend=True)

# Show plot
fig.show()

plt.figure(figsize=(10,5))
sns.barplot(x='Category',y='Sales',data=df,palette='rocket')
plt.title('Category vs Sales',pad=20,fontsize=20,fontweight='bold')
plt.show()

plt.figure(figsize=(10,5))
sns.barplot(x='Category',y='Profit',data=df,palette='magma')
plt.title('Category vs Profit',pad=20,fontsize=20,fontweight='bold')
plt.show()

plt.figure(figsize=(10,5))
sns.barplot(x='Category',y='Discount',data=df,palette='viridis')
plt.title('Category vs Discount',pad=20,fontsize=20,fontweight='bold')
plt.show()

"""##Customer Segment Analysis"""

plt.figure(figsize=(10,5))
# Prepare data
segment_counts = df['Segment'].value_counts()
labels = segment_counts.index
values = segment_counts.values

# Create interactive pie chart
fig = px.pie(
    names=labels,
    values=values,
    title="Segment Distribution",
    hole=0  # Set to 0.3 for a donut chart
)

fig.update_traces(
    textinfo='percent+label',
    pull=[0.1, 0, 0],  # Explode first slice
    marker=dict(colors=['gold', 'skyblue', 'lightgreen']),
    textfont_size=14,
)

fig.update_layout(showlegend=True)

# Show interactive chart
fig.show()

plt.figure(figsize=(10,5))
sns.barplot(x='Segment',y='Profit',data=df,palette='magma')
plt.title('Segment vs Profit',pad=20,fontsize=20,fontweight='bold')
plt.show()

plt.figure(figsize=(10,5))
sns.barplot(x='Segment',y='Discount',data=df,palette='viridis')
plt.title('Segment vs Discount',pad=20,fontsize=20,fontweight='bold')
plt.show()

df['Ship Mode'].value_counts()

"""##Regional Performance Analysis"""

plt.figure(figsize=(10,5))
# Prepare region data
profit_by_region = df.groupby('Region')['Profit'].sum()
sales_by_region = df.groupby('Region')['Sales'].sum()

# Create interactive plot
fig_region = go.Figure()

# Add bars
fig_region.add_trace(go.Bar(
    x=profit_by_region.index,
    y=sales_by_region.values,
    name='Sales',
    marker_color='#1f77b4',
    hovertemplate='<b>%{x}</b><br>Sales: $%{y:,.0f}<extra></extra>'
))

fig_region.add_trace(go.Bar(
    x=profit_by_region.index,
    y=profit_by_region.values,
    name='Profit',
    marker_color='#ff7f0e',
    hovertemplate='<b>%{x}</b><br>Profit: $%{y:,.0f}<extra></extra>'
))

# Update layout
fig_region.update_layout(
    title=dict(
        text='Sales vs Profit by Region',
        x=0.5,  # Center the title
        xanchor='center'
    ),
    xaxis_title='Region',
    yaxis_title='Amount ($)',
    barmode='group',
    hovermode='x unified',
    template='plotly_white',
    height=500,
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
    margin=dict(l=50, r=50, t=80, b=50),
    xaxis=dict(
        tickmode='array',
        tickvals=profit_by_region.index,
        ticktext=['South', 'West', 'East', 'Central']  # Ensure these match your actual region names
    )
)

# Add margin annotations
for region in profit_by_region.index:
    fig_region.add_annotation(
        x=region,
        y=max(sales_by_region[region], profit_by_region[region]) * 1.05,
        text=f"Margin: {(profit_by_region[region]/sales_by_region[region]*100):.1f}%",
        showarrow=False,
        font=dict(size=10)
    )

# Add view toggle
fig_region.update_layout(
    updatemenus=[dict(
        type="buttons",
        direction="right",
        x=0.2, y=1,
        buttons=[
            dict(label="Both", method="update",
                 args=[{"visible": [True, True]}, {"title": "Sales vs Profit by Region"}]),
            dict(label="Sales Only", method="update",
                 args=[{"visible": [True, False]}, {"title": "Sales by Region"}]),
            dict(label="Profit Only", method="update",
                 args=[{"visible": [False, True]}, {"title": "Profit by Region"}])
        ]
    )]
)

fig_region.show()

"""##Super store Sales Overview Dashboard"""

import pandas as pd
import plotly.express as px
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import plotly.io as pio

# Load the data
df = pd.read_excel('Superstore.xlsx', sheet_name='Orders')

# Create interactive plots

## 1. Sales vs Profit by Category
fig1 = px.scatter(df, x='Sales', y='Profit', color='Category',
                 title='Sales vs Profit by Category',
                 hover_data=['Sub-Category', 'Product Name'],
                 template='plotly_white')
fig1.update_layout(showlegend=True)

## 2. Sales vs Discount by Category
fig2 = px.scatter(df, x='Sales', y='Discount', color='Category',
                 title='Sales vs Discount by Category',
                 hover_data=['Sub-Category', 'Product Name'],
                 template='plotly_white')
fig2.update_layout(showlegend=True)

## 3. Sales vs Profit by Segment
fig3 = px.scatter(df, x='Sales', y='Profit', color='Segment',
                 title='Sales vs Profit by Segment',
                 hover_data=['Category', 'Sub-Category'],
                 template='plotly_white')
fig3.update_layout(showlegend=True)

## 4. Sales vs Discount by Segment
fig4 = px.scatter(df, x='Sales', y='Discount', color='Segment',
                 title='Sales vs Discount by Segment',
                 hover_data=['Category', 'Sub-Category'],
                 template='plotly_white')
fig4.update_layout(showlegend=True)

## 5. Sales vs Profit by Region
fig5 = px.scatter(df, x='Sales', y='Profit', color='Region',
                 title='Sales vs Profit by Region',
                 hover_data=['State', 'City'],
                 template='plotly_white')
fig5.update_layout(showlegend=True)

## 6. Sales vs Discount by Region
fig6 = px.scatter(df, x='Sales', y='Discount', color='Region',
                 title='Sales vs Discount by Region',
                 hover_data=['State', 'City'],
                 template='plotly_white')
fig6.update_layout(showlegend=True)

## 7. Sales vs Profit by Ship Mode
fig7 = px.scatter(df, x='Sales', y='Profit', color='Ship Mode',
                 title='Sales vs Profit by Ship Mode',
                 hover_data=['Category', 'Sub-Category'],
                 template='plotly_white')
fig7.update_layout(showlegend=True)

## 8. Sales vs Discount by Ship Mode
fig8 = px.scatter(df, x='Sales', y='Discount', color='Ship Mode',
                 title='Sales vs Discount by Ship Mode',
                 hover_data=['Category', 'Sub-Category'],
                 template='plotly_white')
fig8.update_layout(showlegend=True)

# Create a dashboard with all plots
from plotly.subplots import make_subplots
import plotly.graph_objects as go

fig = make_subplots(
    rows=4, cols=2,
    subplot_titles=("Sales vs Profit by Category", "Sales vs Discount by Category",
                    "Sales vs Profit by Segment", "Sales vs Discount by Segment",
                    "Sales vs Profit by Region", "Sales vs Discount by Region",
                    "Sales vs Profit by Ship Mode", "Sales vs Discount by Ship Mode"),
    horizontal_spacing=0.1,
    vertical_spacing=0.1)

# Add traces from each figure to the dashboard
for trace in fig1.data:
    fig.add_trace(trace, row=1, col=1)

for trace in fig2.data:
    fig.add_trace(trace, row=1, col=2)

for trace in fig3.data:
    fig.add_trace(trace, row=2, col=1)

for trace in fig4.data:
    fig.add_trace(trace, row=2, col=2)

for trace in fig5.data:
    fig.add_trace(trace, row=3, col=1)

for trace in fig6.data:
    fig.add_trace(trace, row=3, col=2)

for trace in fig7.data:
    fig.add_trace(trace, row=4, col=1)

for trace in fig8.data:
    fig.add_trace(trace, row=4, col=2)

# Update layout
fig.update_layout(
    height=1600,
    width=1200,
    showlegend=True,
    template='plotly_white',
    title_text="Superstore Sales Analysis Dashboard",
    title_x=0.5
)

# Show the dashboard
fig.show()

df['Order Date'] = pd.to_datetime(df['Order Date'],errors='coerce')
df['Ship Date'] = pd.to_datetime(df['Ship Date'],errors='coerce')

df['Order Year'] = df['Order Date'].dt.year
df['Order Month'] = df['Order Date'].dt.month
df['Order Day'] = df['Order Date'].dt.day
df['Order Weekday'] = df['Order Date'].dt.dayofweek
df['Ship Year'] = df['Ship Date'].dt.year
df['Ship Month'] = df['Ship Date'].dt.month
df['Ship Day'] = df['Ship Date'].dt.day
df['Ship Weekday'] = df['Ship Date'].dt.dayofweek

df['Profit Margin'] = df['Profit']/df['Sales']
df['Discounted Profit'] = df['Profit']-df['Profit']*df['Discount']
df['Discount Percentage'] = df['Discount']/df['Sales']*100

# Create seasonal features
df['is_holiday'] = (df['Order Month'] == 12) | (df['Order Month'] == 11)  # Holiday season
df['is_weekend'] = df['Order Weekday'].isin([5, 6])  # Weekend indicator

# Create price-related features
df['Price_per_item'] = df['Sales'] / df['Quantity']
df['Profit_per_item'] = df['Profit'] / df['Quantity']

holiday_df = df[df['is_holiday']]
fig = px.histogram(holiday_df, x='Order Weekday', color='Category',
                   title='Weekday Sales Distribution During Holiday Season (Nov-Dec)',
                   nbins=7,  # Ensure one bin per day of the week
                   barmode='group')  # nbins to ensure one bin per day of the week

fig.update_layout(
    xaxis_title='Order Weekday',
    yaxis_title='Count',
    xaxis=dict(tickmode='array', tickvals=list(range(7)),
               ticktext=['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']), # Explicitly label weekdays
    legend_title='Category'
)
fig.show()

fig = px.scatter(df, x='Price_per_item', y='Quantity', color='Category',
                 size='Sales',  # Use 'Sales' or 'Profit' for bubble size
                 title='Quantity Sold vs Price per Item (by Category)',
                 hover_data=['Product Name'], # Add more hover data if needed
                 template='plotly_white')

fig.update_layout(
    shapes=[
        dict(
            type='line',
            yref='paper', y0=0, y1=1,
            xref='x', x0=df['Price_per_item'].median(), x1=df['Price_per_item'].median(),
            line=dict(color='red', dash='dash')
        )
    ]
)

fig.show()

"""##Correlation Analysis"""

df.drop('Row ID',axis=1,inplace=True)

plt.figure(figsize=(10,5))
# Select only numerical features for correlation
numerical_df = df.select_dtypes(include=np.number)
fig = sns.heatmap(numerical_df.corr(),annot=True,cmap='RdYlGn',vmin=-1.0,vmax=1.0)
plt.title('Correlation Heatmap',pad=20,fontsize=20,fontweight='bold')
plt.show()
plt.close('all')
del fig
import gc
gc.collect()

"""##Time Series Analysis"""

# Prepare monthly data
monthly_data = df.groupby(['Order Year', 'Order Month']).agg({'Sales': 'sum', 'Profit': 'sum'}).reset_index()
monthly_data['Year-Month'] = monthly_data['Order Year'].astype(str) + '-' + monthly_data['Order Month'].astype(str)

# Create interactive plot
fig_monthly = make_subplots(specs=[[{"secondary_y": True}]])

# Add traces
fig_monthly.add_trace(
    go.Scatter(
        x=monthly_data['Year-Month'],
        y=monthly_data['Sales'],
        name="Sales",
        line=dict(color='blue'),
        hovertemplate="<b>%{x}</b><br>Sales: $%{y:,.0f}<extra></extra>"
    ),
    secondary_y=False
)

fig_monthly.add_trace(
    go.Scatter(
        x=monthly_data['Year-Month'],
        y=monthly_data['Profit'],
        name="Profit",
        line=dict(color='orange'),
        hovertemplate="<b>%{x}</b><br>Profit: $%{y:,.0f}<extra></extra>"
    ),
    secondary_y=True
)

# Update layout
fig_monthly.update_layout(
    title="Monthly Sales and Profit Trends",
    xaxis_title="Month",
    hovermode="x unified",
    template="plotly_white",
    height=500,
    xaxis=dict(
        tickangle=45,
        rangeslider=dict(visible=True)
    )
)

fig_monthly.update_yaxes(title_text="<b>Sales</b> ($)", secondary_y=False)
fig_monthly.update_yaxes(title_text="<b>Profit</b> ($)", secondary_y=True)

fig_monthly.show()

from statsmodels.tsa.seasonal import seasonal_decompose
# Prepare the time series data
time_series = df.set_index('Order Date')['Sales'].resample('D').sum().ffill()

# Perform decomposition
decomposition = seasonal_decompose(time_series, model='additive')

# Create interactive plot with subplots
fig = make_subplots(
    rows=3, cols=1,
    shared_xaxes=True,
    vertical_spacing=0.3,
    subplot_titles=("Observed", "Trend", "Residual")
)

# Add traces for each component
fig.add_trace(
    go.Scatter(
        x=decomposition.observed.index,
        y=decomposition.observed,
        name='Observed',
        line=dict(color='#1f77b4'),
        hovertemplate='Date: %{x|%b %d, %Y}<br>Sales: $%{y:,.0f}<extra></extra>'
    ),
    row=1, col=1
)

fig.add_trace(
    go.Scatter(
        x=decomposition.trend.index,
        y=decomposition.trend,
        name='Trend',
        line=dict(color='#ff7f0e', width=2),
        hovertemplate='Date: %{x|%b %d, %Y}<br>Trend: $%{y:,.0f}<extra></extra>'
    ),
    row=2, col=1
)

fig.add_trace(
    go.Scatter(
        x=decomposition.resid.index,
        y=decomposition.resid,
        name='Residual',
        line=dict(color='#d62728'),
        hovertemplate='Date: %{x|%b %d, %Y}<br>Residual: $%{y:,.0f}<extra></extra>'
    ),
    row=3, col=1
)

# Update layout
fig.update_layout(
    title='<b>Time Series Decomposition of Sales</b>',
    title_font_size=20,
    title_x=0.5,
    height=800,
    template='plotly_white',
    hovermode='x unified',
    showlegend=False,
    margin=dict(l=50, r=50, t=80, b=50),
)

# Add range slider
fig.update_xaxes(
    rangeslider_visible=True,
    rangeselector=dict(
        buttons=list([
            dict(count=1, label="1m", step="month", stepmode="backward"),
            dict(count=6, label="6m", step="month", stepmode="backward"),
            dict(count=1, label="YTD", step="year", stepmode="todate"),
            dict(count=1, label="1y", step="year", stepmode="backward"),
            dict(step="all")
        ])
    )
)

# Format y-axis labels
fig.update_yaxes(tickprefix="$", tickformat=",")

# Add annotation
fig.add_annotation(
    x=0.5, y=-0.15,
    xref='paper', yref='paper',
    text="<i>Additive decomposition of daily sales data</i>",
    showarrow=False,
    font=dict(size=10, color="grey")
)

fig.show()

"""##Categorical Encoding"""

df['Ship Mode'].unique()

df['Segment'].unique()

df['Category'].unique()

df['Sub-Category'].unique()

df['Region'].unique()

df['State'].unique()

df['City'].unique()

df['Product Name'].nunique()

"""#Modeling"""

# Define features and target
X = df.drop(['Sales', 'Order ID', 'Customer Name', 'Product Name'], axis=1)
y = df['Sales']

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Identify feature types
numeric_features = X.select_dtypes(include=['int64', 'float64']).columns.tolist()
categorical_features = X.select_dtypes(include=['object']).columns.tolist()

# Preprocessing pipelines
numeric_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

categorical_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('encoder', OneHotEncoder(handle_unknown='ignore', sparse_output=False))
])

# Column transformer
preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, numeric_features),
        ('cat', categorical_transformer, categorical_features)
    ])

# Feature selection
feature_selector = SelectKBest(score_func=f_regression, k=15)

# Models to evaluate
models = {
    'Linear Regression': LinearRegression(),
    'Random Forest': RandomForestRegressor(random_state=42),
    'XGBoost': XGBRegressor(random_state=42),
    'Neural Network': MLPRegressor(random_state=42)
}

# Evaluation function
def evaluate_model(model, X_train, y_train, X_test, y_test):
    # Create pipeline
    pipeline = Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('feature_selector', feature_selector),
        ('model', model)
    ])

    # Fit and predict
    pipeline.fit(X_train, y_train)
    y_train_pred = pipeline.predict(X_train)

    train_rmse = np.sqrt(mean_squared_error(y_train, y_train_pred))
    train_mae = mean_absolute_error(y_train, y_train_pred)
    train_r2 = r2_score(y_train, y_train_pred)

    # Test predictions
    y_test_pred = pipeline.predict(X_test)
    test_rmse = np.sqrt(mean_squared_error(y_test, y_test_pred))
    test_mae = mean_absolute_error(y_test, y_test_pred)
    test_r2 = r2_score(y_test, y_test_pred)

    return {
        'train_rmse': train_rmse,
        'train_mae': train_mae,
        'train_r2': train_r2,
        'test_rmse': test_rmse,
        'test_mae': test_mae,
        'test_r2': test_r2,
        'pipeline': pipeline
    }

# Evaluation
results = []
best_test_rmse = float('inf')
best_model = None
best_pipeline = None

for name, model in models.items():
    metrics = evaluate_model(model, X_train, y_train, X_test, y_test)

    results.append({
        'Model': name,
        'Train RMSE': metrics['train_rmse'],
        'Test RMSE': metrics['test_rmse'],
        'Train MAE': metrics['train_mae'],
        'Test MAE': metrics['test_mae'],
        'Train R2': metrics['train_r2'],
        'Test R2': metrics['test_r2']
    })

    if metrics['test_rmse'] < best_test_rmse:
        best_test_rmse = metrics['test_rmse']
        best_model = name
        best_pipeline = metrics['pipeline']

# Display results
results_df = pd.DataFrame(results)
print("\n" + "="*80)
print("Model Evaluation Results (All Metrics)")
print("="*80)
display(results_df.sort_values('Test RMSE'))

print(f"\nBest Model: {best_model} (Test RMSE: {best_test_rmse:.2f})")

avg_sales = y_test.mean()  # Average sale value
error_ratio = 288.513420 / avg_sales * 10  # Error as % of average
print(f"Average Sale: ${avg_sales:.2f}")
print(error_ratio)

# Residual analysis for the best model
y_pred = best_pipeline.predict(X_test)
residuals = y_test - y_pred

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.scatter(y_pred, residuals, alpha=0.5)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel('Predicted Values')
plt.ylabel('Residuals')
plt.title('Residual Plot')

plt.subplot(1, 2, 2)
plt.hist(residuals, bins=30, alpha=0.7, color='blue', edgecolor='black')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.title('Residual Distribution')
plt.tight_layout()
plt.show()

# Actual vs Predicted plot
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred, alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
plt.xlabel('Actual Sales')
plt.ylabel('Predicted Sales')
plt.title(f'Actual vs Predicted Sales - {best_model}')
plt.show()